This course covers the basic, foundational tools you'll need to evaluate algorithms, understand how they perform, compare them to each other, and know which ones to use in a given context.

Python is used.

If you're a JS developer (yes), Python will be understandable apparently.

An algorithm is a step of instructions for completing a task (e.g. a recipe, a google maps direction etc.).

In the computer science context, algorithms are a way to solve a problem given the constraints of programming languages.

The field of computer science has identified several algorithms that can be used to solve particular problems.

Knowining these algorithms makes you a faster programmer as you don't need to come up with it yourself. It also allows you to use the best one for the current task.

You break down a problem into multiple steps, each of which may have a particular best algorithm.

This is called algorithmic thinking.

Being able to break down a problem into smaller chunks and identify the right algorithm for the task is extremely important in programming.

One common programming problem is searching through values. In big datasets, it would be absurd to go through the values from the first till the correct one is found as it would take too long. 

This is called linear/sequential/simple search.

Linear search is a search algorithm, where you start at the beginning of the set of values. You compare that value to the value you wish to find. If they don't match then you go on to the next value.

This is an algorithm because of the specificity of the steps. The first step to defining an algorithm is having a clear *problem statement*.

In defining the problem, you need to specify the problem and the output that the algorithm provides.

Once we have a problem, an algorithm is a specific set of instructions in a particular order to solve that problem.

Each step needs to be clear, distinct, and atomic. The algorithm must produce a result.

The end result can be nothing, indicating that the target wasn't found.

The algorithm must complete, and shouldn't take an infinite amount of time.

Algorithm - 

1. Clearly defined problem statement, input, and output
2. Steps should be in a specific order
3. Steps should be distinct
4. Algorithm should produce a result
5. Algorithm should complete in a finite amount of time

What is a good algorithm? 

There is no one way to evaluate an algorithm as it's context-based.

A correct algorithm always get the output we expect, and always terminates.

There's a bunch of mathematics used to design mathematics but this course won't go into that.

Efficiency is measured by time and space.

Time Complexity - how long it takes to run
Space Complexity - the amount of memory taken up by the computer

A good algorithm straddles both to be fast but use as little memory as possible.

When measuring efficiency, we also use the worst case scenario. For example, a linear search for the number 100 in a list of 100 sequential numbers would take 100 goes. Therefore linear search efficiency is 100 for this problem.

We use growth rates to evaluate how an algorithm performs as the dataset grows.

Big O is the theoretical definition of the complexity of an algorithm as a function of the size.

It's a notation used to define complexity.

An example of this notation is:

O(n). 

Complexity is relative. It's relative to other algorithms of the same type (e.g. search).

Big O is a function of size, and the upper bounds of the algorithm (how the algorithm performs in the worst possible scenario).

Linear Search - O(n)
Binary Search - O(log n)

Common Notations:

Constant Time = O(1) [most ideal time]
Logarithmic Time = O(log n) [also called linear - very efficient]
Linear Time = O(n) [slower the bigger the dataset]

Linear search is more performant up to a certain value of n.

 





